学习笔记


---- 第一周
1.数组
    一种线性表数据结构。
    它用一组连续的内存空间，来存储一组具有相同类型的数据。
2.链表
    数据排成像一条线一样的结构。
    每个线性表上的数据最多只有两个方向。
    除了数组，链表、队列、栈也是线性表结构。
（与线性表对立的是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。）

    参考：
https://www.cnblogs.com/fengxiaoyuan/p/10934399.html
https://blog.csdn.net/mingyunxiaohai/article/details/85758347

3.跳表
    增加了向前指针的链表叫作跳表。
    跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。
    快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。

    参考：
https://zhuanlan.zhihu.com/p/68516038
---- 第二周
1.哈希表、映射、集合
2.树、二叉树、二叉搜索树
3.
Q1.js中的 hash table 与 hash map ？
Q2.Java中的 hash table 与 hash map ？
---- 第三周
---- 第四周
学习笔记


1.深度优先搜索（dfs）

    是对先序遍历的推广。
    对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
    
2.广度优先搜索（bfs）

    按照层处理顶点（分支？）距离开始点最近的那些顶点被首先求值，而最远的顶点被最后求值。
    这很像对树的层序遍历。
    
Q. 图论算法？


3.贪心算法

    分阶段地工作。
    在每一个阶段做出认为是最好的决定，而不考虑将来的后果（局部最优）。
    算法终止时，希望全部的局部最优得到全局最优。

    适用场景：
    简单地说，问题能够分成子问题来解决，子问题的最优解能递推到最终结果问题的最优解。
    这种子问题最优解称为最优子结构。

    贪心算法与动态规划的不同在于：
    贪心算法对于每一个子问题的解决方式都做出了选择，不能回退。
    动态规划则会保留以前的结果运算，并根据以前的结果对当前进行选择，有回退功能。
    
    【贪心：当下做局部最优判断】
    【回溯：能够回退】
    【动态规划：最优判断 + 回退】
    
    一般用以解决最优问题。
    以但有一个问题可以通过贪心来解决，那么贪心算法一般是解决这个问题的最好办法。
    由于贪心算法的高校新以及所求得的答案比较接近最优结果，也可以用于辅助算法，或直接解决一些要求结果不是特别精确的问题。

Q.有几个可做扩展的例子

    ·操作系统调度程序
        一般把优先权赋予那些耗时更短的任务：
        所用时间不是单调非减的任何任务调度必然是次最优的。
        剩下的只有那些其作业按照最小运行时间最先安排的调度才是所有调度方案中最优的。
        
    ·文件压缩（哈夫曼编码）
    
    ·近似装箱问题
    
Q.Dijkstra算法、Prim算法、Kruskal算法了解一下？


4.二分查找
    从有序数组的两边，逐渐的向所要查找的元素周围逼近，最终锁定元素。
    理解上可以类比一下夹逼准则。

    前提（适用）：
    目标函数单调性
    存在上下界
    能够通过索引访问
    
Q.牛顿迭代法

Q.查找资料时，有说：二分查找是分治算法的一个实例

    也有另一说法：传统上，在正文中至少含有两个递归调用的例程叫做分治算法。
    （二分查找只能算是有一个？）
    
    分治算法：
        把一个大问题分解为两个相对较小的问题，分别解决每一个小问题，对两个小问题的处理方式也一样：分解为两个更小的问题，并解决它们
        这个过程一直持续下去直到达到易于求解的基值情况，就不用继续分解下去了
        
    分治算法最典型的例子是：归并排序、快速排序
    
Q.使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方

    说明：同学们可以将自己的思路、代码写在第 4 周的学习总结中

    找寻一个中间值将数组二分为两个数组。
    分别找出两个数组的中间值并根据，两个数组分别的左、中、右三个值判断是否具有单调性。
    如若都具有单调性，则分出两个数组的中间值即为中间无序的地方。
    若是其中一个数组为呈现出单调性，则继续以分治的方式进行递归。
---- 第五周
---- 第六周、第七周合并
1.Trie（前缀树， 字典树）
    ·找到具有同一前缀的全部键值。
    ·按词典序枚举字符串的数据集。
Q.随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 O(n)O(n)，其中 nn 是插入的键的数量。
与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。
此时 Trie 树只需要 O(m)O(m) 的时间复杂度，其中 mm 为键长。
而在平衡树中查找键值需要 O(m \log n)O(mlogn) 时间复杂度。
    ·Trie 树的结点结构
    ·Trie 树是一个有根的树，其结点具有以下字段：
        ··最多 RR 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母
        ··布尔字段，以指定节点是对应键的结尾还是只是键前缀

2.并查集

3.高级搜索
    3.1.剪枝
    3.2.双向dfs
    3.3.启发式搜索 -> A星算法
红黑树

AVL树
---- 第八周
1.位运算
    程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。
    
    1.1.运算符号编辑
        （下面的a和b都是整数类型），则：
        含义         Pascal语言    C语言         Java
        按位与       a and b       a & b         a & b
        按位或       a or b        a | b         a | b
        按位异或     a xor b       a ^ b         a ^ b
        按位取反     not a         ~a            ~a
        左移        a shl b       a << b        a << b
        带符号右移   a shr b       a >> b         a >> b
        无符号右移   /             /              a>>> b
    1.2.奇偶性
    1.3.个数计算
    1.4.查找
    1.5.逆序
2.布隆过滤器(Bloom Filter)
    ·一个很长的二进制向量 （位数组）
    ·一系列随机函数 (哈希)
    ·空间效率和查询效率高
    ·有一定的误判率（哈希表是精确匹配）
布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数（随机函数）。
    2.1.布隆过滤器添加元素
        将要添加的元素给k个哈希函数
        得到对应于位数组上的k个位置
        将这k个位置设为1
    2.2.布隆过滤器查询元素
        将要查询的元素给k个哈希函数
        得到对应于位数组上的k个位置
        如果k个位置有一个为0，则肯定不在集合中
        如果k个位置全部为1，则可能在集合中
    2.3.布隆过滤器实现
        参考
        https://github.com/cpselvis/zhihu-crawler/blob/master/bloom_filter.py
3.排序
    比较类排序
        通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
    非比较类排序
        不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序
    参考
    https://www.cnblogs.com/onepixel/p/7674659.html
    3.1.初级排序
    3.2.高级排序
---- 第九周
1.高级动态规划
    一种分阶段求解决策略的数学思想
    1.1.分治
        分 + 治 =（递归解决较小问题，基本情况除外）+（从子问题的解构建原问题的解）
        传统上，正文中至少含有两个递归调用的例程叫做分治算法（只含一个递归调用的历程不是分治算法）。
        一般坚持子问题是不相交的。
        Q.最近点问题
        Q.选择问题
    1.2.动态规划
        用一个表代替递归
        （举例：fib可用递归简单实现，然以一个表代替递归，则更优一些）
        Q.矩阵陈发的顺序安排
        Q.最优二叉查找树
2.字符串算法
    字符串(String)是由数字、字母、下划线组成的一串字符。
    在程序设计中，字符串（string）为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。

    java、python等语言中，字符串（string）是不可变的，一旦创建就不能修改。
    Q.提问 其他语言呢？
    Q.提问 硬是要修改呢？

    2.1.字符串的基本操作
p1.不同路径 2 （ https://leetcode-cn.com/problems/unique-paths-ii/ ）这道题目的状态转移方程。
    一维：
        f[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        f[j] += f[j - 1];
    二维：
        dp[i][0] = 1;
        dp[0][j] = 1;
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];